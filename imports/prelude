-- Logical Combinators

i = \x -> x

s = \x -> \y -> \z -> x z (y z)

k = \x -> \y -> x

b = \x -> \y -> \z -> x (y z)

y = \f -> (\x -> f (x x)) (\x -> f (x x))

t = \x -> \y -> y x

m = \x -> x x

o = (\x -> x x) (\x -> x x)

-- Data types

data Maybe = Just a | Nothing

maybe :: b -> (a -> b) -> Maybe -> b
maybe x _ Nothing = x
maybe _ f (Just y) = f y

data Either = Left a | Right b

either :: (a -> c) -> (b -> c) -> Either -> c
either f _ (Left x) = f x
either _ g (Right y) = g y

-- Boolean

not :: Bool -> Bool
not True = False
not False = True

otherwise :: Bool
otherwise = True

-- Tuples

fst :: (a, b) -> a
fst (x, _) = x
fst _ = error "'fst' can only be used on a pair (tuple of size 2)"

snd :: (a, b) -> b
snd (_, y) = y
snd _ = error "'snd' can only be used on a pair (tuple of size 2)"

curry :: ((a, b) -> c) -> a -> b -> c
curry f x y = f (x, y)

uncurry :: (a -> b -> c) -> (a, b) -> c
uncurry f (x, y) = f x y

-- Doubles

succ :: Double -> Double
succ x = x + 1

pred :: Double -> Double
pred x = x - 1

negate :: Double -> Double
negate x = (-x)

abs :: Double -> Double
abs x = if x < 0 then (-x) else x

signum :: Double -> Double
signum x = if x < 0 then (-1) else 1

quot :: Double -> Double -> Double
quot x y = if x / y < 0 then ceiling (x / y) else floor (x / y)

rem :: Double -> Double -> Double
rem x y = x - (quot x y) * y

div :: Double -> Double -> Double
div x y = floor (x / y)

mod :: Double -> Double -> Double
mod x y = x - (div x y) * y

quotRem :: Double -> Double -> (Double, Double)
quotRem x y = (quot x y, rem x y)

divMod :: Double -> Double -> (Double, Double)
divMod x y = (div x y, mod x y)

truncate :: Double -> Double
truncate x = if x < 0 then ceiling x else floor x

round :: Double -> Double
round x = if x - floor x < 0.5 then floor x else
    if x - floor x > 0.5 then ceiling x else
    if even (floor x) then floor x else ceiling x

isInt :: Double -> Bool
isInt x = x == floor x

subtract :: Double -> Double -> Double
subtract x y = y - x

even :: Double -> Bool
even x = mod x 2 == 0

odd :: Double -> Bool
odd x = mod x 2 == 1

-- Miscellaneous Functions

id :: a -> a
id x = x

const :: a -> b -> a
const x _ = x

flip :: (a -> b -> c) -> b -> a -> c
flip f x y = f y x

until :: (a -> Bool) -> (a -> a) -> a -> a
until p f x = if p x then x else until p f (f x)

undefined :: a
undefined = error "undefined"

-- List Operations

elem :: a -> [a] -> Bool
elem _ [] = False
elem e (x:xs) = if e == x then True else elem e xs

notElem :: a -> [a] -> Bool
notElem e xs = not $ elem e xs

maximum :: [Double] -> Double
maximum [x] = x
maximum (x:xs) = if x > maximum xs then x else maximum xs
maximum [] = error "'maximum' cannot be used on an empty list"

minimum :: [Double] -> Double
minimum [x] = x
minimum (x:xs) = if x < minimum xs then x else minimum xs
minimum [] = error "'minimum' cannot be used on an empty list"

sum :: [Double] -> Double
sum [] = 0
sum (x:xs) = x + sum xs

product :: [Double] -> Double
product [] = 1
product (x:xs) = x * product xs

map :: (a -> b) -> [a] -> [b]
map _ [] = []
map f (x:xs) = f x : map f xs

filter :: (a -> Bool) -> [a] -> [a]
filter f [] = []
filter f (x:xs) = if f x then x : filter f xs else filter f xs

head :: [a] -> a
head (x:_) = x
head [] = error "'head' cannot be used on an empty list"

last :: [a] -> a
last [x] = x
last (_:xs) = last xs
last [] = error "'last' cannot be used on an empty list"

tail :: [a] -> [a]
tail [] = []
tail (_:xs) = xs

init :: [a] -> [a]
init [x] = []
init (x:xs) = x : init xs
init [] = error "'init' cannot be used on an empty list"

null :: [a] -> Bool
null [] = True
null _ = False

length :: [a] -> Double
length [] = 0
length (_:xs) = length xs + 1

reverse :: [a] -> [a]
reverse [] = []
reverse (x:xs) = reverse xs ++ [x]

and :: [Bool] -> Bool
and [] = True
and (False : xs) = False
and (True : xs) = and xs

or :: [Bool] -> Bool
or [] = False
or (False : xs) = or xs
or (True : xs) = True

any :: (a -> Bool) -> [a] -> Bool
any f xs = or $ map f xs

all :: (a -> Bool) -> [a] -> Bool
all f xs = and $ map f xs

concat :: [[a]] -> [a]
concat [] = []
concat (x:xs) = x ++ concat xs

concatMap :: (a -> [b]) -> [a] -> [b]
concatMap f xs = concat $ map f xs

intercalate :: [a] -> [[a]] -> [a]
intercalate _ [] = []
intercalate _ [x] = x
intercalate y (x:xs) = x ++ y ++ intercalate y xs

replicate :: Int -> a -> [a]
replicate n x = replicator n x []

replicator :: Int -> a -> [a] -> [a]
replicator 0 _ xs = xs
replicator n x xs = if n > 0 then replicator (n-1) x (x:xs) else error "'replicate' can only take a positive integer as the first argument"

take :: Double -> [a] -> [a]
take 0 _ = []
take _ [] = []
take n (x:xs) = if n > 0 then x : take (n-1) xs else error "'take' can only take a positive integer as the first argument"

drop :: Double -> [a] -> [a]
drop 0 xs = xs
drop _ [] = []
drop n (x:xs) = if n > 0 then drop (n-1) xs else error "'drop' can only take a positive integer as the first argument"

takeWhile :: (a -> Bool) -> [a] -> [a]
takeWhile f [] = []
takeWhile f (x:xs) = if f x then x : takeWhile f xs else []

dropWhile :: (a -> Bool) -> [a] -> [a]
dropWhile f [] = []
dropWhile f (x:xs) = if f x then dropWhile f xs else (x:xs)

span :: (a -> Bool) -> [a] -> ([a], [a])
span f xs = (takeWhile f xs, dropWhile f xs)

break :: (a -> Bool) -> [a] -> ([a], [a])
break f = span (not . f)

splitAt :: Double -> [a] -> ([a], [a])
splitAt n xs = (take n xs, drop n xs)

-- Zipping and Unzipping Lists

zip :: [a] -> [b] -> [(a, b)]
zip [] _ = []
zip _ [] = []
zip (x:xs) (y:ys) = (x, y) : zip xs ys

zip3 :: [a] -> [b] -> [c] -> [(a, b, c)]
zip3 [] _ _ = []
zip3 _ [] _ = []
zip3 _ _ [] = []
zip3 (x:xs) (y:ys) (z:zs) = (x, y, z) : zip3 xs ys zs

zipWith :: (a -> b -> c) -> [a] -> [b] -> [c]
zipWith _ [] _ = []
zipWith _ _ [] = []
zipWith f (x:xs) (y:ys) = f x y : zipWith f xs ys

zipWith3 :: (a -> b -> c -> d) -> [a] -> [b] -> [c] -> [d]
zipWith3 _ [] _ _ = []
zipWith3 _ _ [] _ = []
zipWith3 _ _ _ [] = []
zipWith3 f (x:xs) (y:ys) (z:zs) = f x y z : zipWith3 xs ys zs

unzip :: [(a, b)] -> ([a], [b])
unzip [] = ([], [])
unzip ((x, y) : zs) = (x : fst (unzip zs), y : snd (unzip zs))